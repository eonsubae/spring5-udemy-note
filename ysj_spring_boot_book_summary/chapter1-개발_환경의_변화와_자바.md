# Chapter 1. 개발 환경의 변화와 자바

### 1.1 인프라와 스프링 프레임워크의 변화

최신 웹 개발 트렌드
* 프라모델 조립처럼 여러 오픈 소스를 부품처럼 조합해 서비스를 출시하는 경향이 나타남
* 이렇게 오픈 소스가 활성화 되기까지는 퍼스널 컴퓨터부터 인프라까지 많은 변화가 필요했다

### 1.1.1 아키텍처의 변화

B2C
* 웹의 활성화, 닷컴 열풍으로 온라인 쇼핑몰 등 B2C가 대세가 되면서 아키텍처에 변화를 가져왔다

변화의 흐름 정리
* 서버 / 클라이언트 개념
  - 사용자를 위한 GUI 개발이 본격화
  - 델파이로 만든 업무 프로그램, ActiveX로 웹에서도 애플리케이션 실행
* 서버에 파일을 저장하고 소켓 통신으로 클라이언트와 통신하는 방식의 유행
* 전자 상거래 활성화
  - 웹의 인기 급증
  - RDB 흥행
  - 통신이 클라 / 서버 구조에서 3티어 방식(DB -> JSP, PHP, ASP -> 클라이언트)으로 변화
* IDC에서 클라우드로
  - 물리장비를 이용하는 IDC는 성능은 좋지만 사용자 수 변동폭이 큰 서비스를 운영하기에는 품질 유지가 쉽지 않았다
  - 이때문에 자유롭게 확장가능한 클라우드가 대안으로 등장했다

### 1.1.2 스프링 프레임워크의 변화

스타트업 활성화
* 작은 규모로 빠르게 서비스 런칭
  - 클라우드 사용 증가
  - JDK, 톰캣, XML 등의 설정이 필요없는 ROR, Django 이용 증가
  - 스프링 진영에서는 이런 문제를 해결하기 위해 스프링 부트를 만들었다

스프링 부트
* 설정 자동화AutoConfigure
  - 스프링 MVC 모듈의 DispatcherServlet 설정, JDBC DataSource 설정 등 인프라를 자동으로 제공
  - 더 이상 복잡한 web.xml 등의 설정이 필요 없어졌다
  - 실행 시에도 임베디드 톰켓을 사용해 톰캣이 main 메서드로 실행이 가능해졌다
  - 그리고 클라우드 환경에서도 별도의 작업 없이 시간을 단축할 수 있다

### 1.2 웹 애플리케이션 컨테이너

웹 애플리케이션 컨테이너
* 웹 애플리케이션이 배포되는 공간을 의미
  - HTML 등 정적 파일을 전달해주는 것을 웹 서버라 한다
  - PHP, JSP, ASP로 동적 페이지 생성이 가능한 서버를 웹 애플리케이션 서버(혹은 컨테이너)WAS라 한다
  - WAS가 어떻게 웹 애플리케이션을 인식하고 동작하는지 알기 위해서는 클래스 로더를 알아야 한다

### 1.2.1 자바 개발을 위해 꼭 필요한 클래스 로더

Write once, run anywhere
* 한번 작성하면 어디서든 실행가능한 특징을 가능하게 한 기술이 클래스 로더다
  - 자바 코드 실행을 위해서는 컴파일을 통해 JVM에서 실행 가능하게 만들어야 한다
  - 이때 JVM이 클래스를 실행하기 위해서 클래스를 로딩해야 한다
  - 클래스 로더는 이 작업을 수행한다
* ex. ClassNotFoundException
  - 클래스 로더가 특정 클래스를 인식할 수 없을 때 발생하는 에러

### 1.2.1.1 클래스 로더의 특징

클래스 로더의 네 가지 특징
* 계층적 구조
  - 상위 클래스 로더가 하위 클래스 로더를 소유
  - 최상위 클래스 로더를 부트스트랩 클래스 로더라고 한다
* 위임가능한 클래스 로딩
* 가시적 규약의 존재
  - 클래스를 로딩할 때 가능한 범위에 제약이 있다는 의미다
  - 자식 클래스 로더는 클래스 로딩 요청 위임으로 부모 클래스 로더가 로딩한 클래스를 찾을 수 있다
  - 반대(부모 -> 자식 위임)는 불가능하다
* 불가능한 클래스 언로딩
  - 클래스 로더로 로딩한 클래스는 언로딩할 수 없다
  - gc가 동작하거나 WAS가 재시작할 때 초기화된다

### 1.2.1.2 클래스 로더의 유형

클래스 로더의 네 가지 유형
* 부트스트랩 클래스 로더
  - JVM 런타임 실행을 위해 기반이 되는 파일들을 로드한다
  - rt.jar 파일과 연관
* 확장 클래스 로더
  - 부트스트랩 로더가 로딩이 끝나면 자바의 최상위 객체인 Object를 포함한 자바 API를 로드한다
  - 자바 홈 폴더 하위의 ext 폴더 하위에 있는 JAR 파일과 연관
* 시스템 클래스 로더
  - 확장 로더의 로딩이 끝나면 클래스 패스에 포함된 클래스들을 로드한다
  - 사용자는 시스템 클래스 로더가 로드하는 클래스 패스에만 접근 가능
  - 로컬에서 외부 라이브러리를 사용할 때 클래스 패스를 지정해서 실행하기도 한다
* 사용자 정의 클래스 로더
  - 독립적 영역이 필요한 WAS의 경우 시스템 로더 하위에 사용자 정의 로더를 만든다
  - ex. 대부분의 개발 환경 설정 문서 - 톰캣 설치 위치를 CATALINA_HOME으로 지정
  - 이는 WAS에서 생성한 클래스 로더를 기준으로 동작하기 위함이다

### 1.3 WAR 파일의 특성

배포시 설정
* 로컬 실행 프로그램
  - JAR로 패키징
* 웹 
  - WAR로 패키징
  - WAR는 압축 파일에 자바 관련 규약이 포함된 것이다
  - 웹 애플리케이션 컨테이너는 WAR 파일의 WEB-INF 폴더를 기준으로 클래스 파일들을 로드한다
  
content directory
* HTML, CSS, JS를 포함한 JSP 파일처럼 브라우저에서 보여 줘야 하는 정적 자원 관리를 위한 폴더
* 이 파일들은 브라우저에서 직접 접근이 가능해 WAR 파일의 상위에 두지 않고 WEB-INF 하위에 설정하는 추세다
* WAR로 패키징하면 클래스 파일들은 WEB-INF 하위 classes 폴더에 저장된다

libs
* JAR 형식의 외부 라이브러리들이 있는 폴더
* 이 폴더의 라이브러리들은 사용자 정의 클래스 로더, 웹 애플리케이션 컨테이너의 로더를 통해 클래스패스에 추가된다

웹 애플리케이션 클래스 로더
* 시스템 클래스 로더 하위에 사용자가 정의한 클래스 로더에 해당
* 웹 애플리케이션 자체 API 제공을 위해 컨테이너를 로드하는 클래스 로더를 사용
* 사용자가 추가한 JSP나 WAR 파일들을 다루기 위한 ServletContext Loader를 사용
 
컨테이너 시작 
* 컨텍스트 초기화
* 서블릿 스펙의 권장사항에 따라 WEB-INF/classes 파일을 검색해서 로딩
* 그 후에 WEB-INF/libs에 있는 JAR 파일들을 로드